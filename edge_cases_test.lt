# ===============================
# LATCH EDGE CASES & UNIT TESTS
# Boundary conditions and error scenarios
# ===============================

print("=== LATCH EDGE CASES & UNIT TESTS START ===")
total_tests := 0
passed_tests := 0

# Helper function to report test results
fn assert(condition, message) {
    total_tests += 1
    if condition {
        print("‚úì PASS: ${message}")
        passed_tests += 1
    } else {
        print("‚úó FAIL: ${message}")
    }
}

# ===============================
# 1. NUMERIC EDGE CASES
# ===============================

print("\n--- NUMERIC EDGE CASES ---")

# Zero operations
assert(0 + 0 == 0, "Zero addition")
assert(0 * 5 == 0, "Zero multiplication")
assert(5 * 0 == 0, "Zero multiplication reverse")
assert(0 / 1 == 0, "Zero division")
assert(0 % 1 == 0, "Zero modulo")

# Large numbers
big_num := 999999999
assert(big_num > 0, "Large number handling")
assert(-big_num < 0, "Large negative number")

# Float edge cases
assert(3.14159 > 3.14, "Float comparison")
assert(0.0 + 1.0 == 1.0, "Float addition")

# ===============================
# 2. STRING EDGE CASES
# ===============================

print("\n--- STRING EDGE CASES ---")

# Empty strings
empty := ""
assert(len(empty) == 0, "Empty string length")
assert(empty == "", "Empty string equality")

# String with special characters
special := "Hello\nWorld\t!@#$%^&*()"
assert(len(special) > 10, "Special character string")
assert(contains(special, "\n"), "Newline in string")
assert(contains(special, "\t"), "Tab in string")

# Unicode strings
unicode := "Hello ‰∏ñÁïå üåç"
assert(len(unicode) > 5, "Unicode string handling")
assert(contains(unicode, "‰∏ñÁïå"), "Unicode character detection")

# String operations on edge cases
assert(trim("") == "", "Trim empty string")
assert(lower("") == "", "Lower empty string")
assert(upper("") == "", "Upper empty string")

# ===============================
# 3. LIST/DICT EDGE CASES
# ===============================

print("\n--- LIST/DICT EDGE CASES ---")

# Empty collections
empty_list := []
empty_dict := {}

assert(len(empty_list) == 0, "Empty list length")
assert(len(empty_dict) == 0, "Empty dict length")
empty_keys := keys(empty_dict)
empty_values := values(empty_dict)
assert(len(empty_keys) == 0, "Empty dict keys")
assert(len(empty_values) == 0, "Empty dict values")

# Single item collections
single_list := [42]
single_dict := {"key": "value"}

assert(len(single_list) == 1, "Single item list")
assert(len(single_dict) == 1, "Single item dict")
assert(single_list[0] == 42, "Single list item access")
assert(single_dict["key"] == "value", "Single dict item access")

# Nested empty structures
nested_empty := {"empty": [], "data": {}}
assert(len(nested_empty["empty"]) == 0, "Nested empty list")
assert(len(nested_empty["data"]) == 0, "Nested empty dict")

# ===============================
# 4. BOOLEAN LOGIC EDGE CASES
# ===============================

print("\n--- BOOLEAN LOGIC EDGE CASES ---")

# Truthy/falsy values
assert(true && true == true, "True AND true")
assert(true && false == false, "True AND false")
assert(false && false == false, "False AND false")
assert(true || false == true, "True OR false")
assert(false || false == false, "False OR false")

# Negation
assert(!true == false, "Not true")
assert(!false == true, "Not false")

# Complex boolean expressions
assert((true && false) || true == true, "Complex boolean 1")
assert(true && (false || true) == true, "Complex boolean 2")

# ===============================
# 5. NULL HANDLING EDGE CASES
# ===============================

print("\n--- NULL HANDLING EDGE CASES ---")

# Null comparisons
assert(null == null, "Null equality")
assert(null != "", "Null not equal empty string")
assert(null != 0, "Null not equal zero")
assert(null != [], "Null not equal empty list")
assert(null != {}, "Null not equal empty dict")

# Null coalescing
assert(null ?? "default" == "default", "Null coalescing with null")
assert("value" ?? "default" == "value", "Null coalescing with value")

# Safe access with null
null_var := null
assert(null_var?.property == null, "Safe access on null")

# ===============================
# 6. RANGE EDGE CASES
# ===============================

print("\n--- RANGE EDGE CASES ---")

# Single value ranges
single_range := 5..5
print("Single range: ${single_range}, length: ${len(single_range)}")
# Note: Range behavior might be different than expected

# Empty ranges (if supported)
empty_range := 5..4
# Note: This might return [] or [5], depending on implementation
assert(len(empty_range) <= 1, "Empty or single range")

# Large ranges
large_range := 0..1000
assert(len(large_range) == 1000, "Large range length")

# Negative ranges
neg_range := -5..5
assert(len(neg_range) == 10, "Negative range")

# ===============================
# 7. FUNCTION EDGE CASES
# ===============================

print("\n--- FUNCTION EDGE CASES ---")

# No parameters
fn no_params() {
    return "no_params_result"
}
assert(no_params() == "no_params_result", "No parameter function")

# Multiple parameters
fn multi_params(a, b, c) {
    return a + b + c
}
assert(multi_params(1, 2, 3) == 6, "Multiple parameters")

# Function with no return
fn no_return(x) {
    print("No return: ${x}")
}
result := no_return("test")
# result should be null/undefined
assert(result == null or result == "", "No return function")

# Recursive function edge case
fn recursive_sum(n) {
    if n <= 0 {
        return 0
    } else {
        return n + recursive_sum(n - 1)
    }
}
assert(recursive_sum(5) == 15, "Recursive function")

# ===============================
# 8. ERROR HANDLING EDGE CASES
# ===============================

print("\n--- ERROR HANDLING EDGE CASES ---")

# Type conversion errors
caught_type_error := false
try {
    x := int("not_a_number")
} catch e {
    caught_type_error = true
}
assert(caught_type_error, "Type conversion error caught")

# File not found error
caught_file_error := false
try {
    content := fs.read("definitely_not_existing_file.txt")
} catch e {
    caught_file_error = true
}
assert(caught_file_error, "File not found error caught")

# Division by zero
caught_div_zero := false
try {
    result := 10 / 0
} catch e {
    caught_div_zero = true
}
assert(caught_div_zero, "Division by zero error caught")

# Index out of bounds
caught_index_error := false
try {
    empty_list := []
    item := empty_list[0]
} catch e {
    caught_index_error = true
}
assert(caught_index_error, "Index out of bounds error caught")

# ===============================
# 9. OPERATOR PRECEDENCE EDGE CASES
# ===============================

print("\n--- OPERATOR PRECEDENCE EDGE CASES ---")

# Complex arithmetic
assert(2 + 3 * 4 == 14, "Multiplication precedence")
assert((2 + 3) * 4 == 20, "Parentheses override")

# Mixed operations
assert(10 - 2 * 3 + 4 / 2 == 8, "Mixed arithmetic precedence")

# Logical and arithmetic
assert(5 > 3 && 2 < 4 == true, "Comparison and logical precedence")

# Helper function for sum
fn sum_list(numbers) {
    total := 0
    for num in numbers {
        total += num
    }
    return total
}

# Pipe operator precedence
result := [1, 2, 3] |> map(fn(x) { return x * 2 }) |> sum_list()
assert(result == 12, "Pipe operator precedence")

# ===============================
# 10. TYPE COERCION EDGE CASES
# ===============================

print("\n--- TYPE COERCION EDGE CASES ---")

# String to number
assert(int("42") == 42, "String to int conversion")
assert(float("3.14") == 3.14, "String to float conversion")

# Number to string
assert(str(42) == "42", "Int to string conversion")
assert(str(3.14) == "3.14", "Float to string conversion")

# Boolean to string
assert(str(true) == "true", "Boolean true to string")
assert(str(false) == "false", "Boolean false to string")

# Invalid conversions
caught_invalid_int := false
try {
    x := int("")
} catch e {
    caught_invalid_int = true
}
assert(caught_invalid_int, "Invalid int conversion caught")

# ===============================
# 11. PARALLEL EXECUTION EDGE CASES
# ===============================

print("\n--- PARALLEL EXECUTION EDGE CASES ---")

# Empty parallel loop
parallel_count := 0
parallel item in [] workers=2 {
    parallel_count += 1
}
assert(parallel_count == 0, "Empty parallel loop")

# Single item parallel
single_parallel_count := 0
parallel item in [1] workers=2 {
    single_parallel_count += 1
}
assert(single_parallel_count == 1, "Single item parallel")

# More workers than items
worker_count := 0
parallel item in [1, 2] workers=10 {
    worker_count += 1
}
assert(worker_count == 2, "More workers than items")

# ===============================
# 12. MEMORY EDGE CASES
# ===============================

print("\n--- MEMORY EDGE CASES ---")

# Large string creation
large_string := ""
for i in 0..10000 {
    large_string += "x"
}
print("Large string creation: ${len(large_string)} chars")

# Large list creation
large_list := range(0, 5000)
assert(len(large_list) == 5000, "Large list creation")

# Memory cleanup
large_string := null
large_list := null
assert(large_string == null, "Memory cleanup string")
assert(large_list == null, "Memory cleanup list")

# ===============================
# 13. PIPE OPERATOR EDGE CASES
# ===============================

print("\n--- PIPE OPERATOR EDGE CASES ---")

# Pipe with empty list
empty_pipe := [] |> sort()
assert(len(empty_pipe) == 0, "Pipe with empty list")

# Pipe with single item
single_pipe := [5] |> map(fn(x) { return x * 2 })
assert(single_pipe[0] == 10, "Pipe with single item")

# Multiple pipe operations
multi_pipe := [1, 2, 3, 4, 5]
    |> filter(fn(x) { return x % 2 == 0 })
    |> map(fn(x) { return x * 3 })
    |> sort()
print("Multi pipe result: ${multi_pipe}")
# Note: List comparison might not work as expected

# ===============================
# 14. SAFE ACCESS EDGE CASES
# ===============================

print("\n--- SAFE ACCESS EDGE CASES ---")

# Deep safe access chain
deep_data := {"a": {"b": {"c": {"d": "value"}}}}
assert(deep_data?.a?.b?.c?.d == "value", "Deep safe access")

# Safe access with missing property
missing_data := {"a": {"b": {}}}
assert(missing_data?.a?.b?.c?.d == null, "Safe access missing property")

# Safe access on null
null_data := null
assert(null_data?.anything == null, "Safe access on null")

# ===============================
# 15. IN OPERATOR EDGE CASES
# ===============================

print("\n--- IN OPERATOR EDGE CASES ---")

# In empty collections
assert(! (5 in []), "Not in empty list")
assert(! ("key" in {}), "Not in empty dict")

# In single item collections
assert(5 in [5], "In single item list")
assert("key" in {"key": "value"}, "In single item dict")

# String membership
assert("a" in "abc", "Character in string")
assert("ab" in "abc", "Substring in string")
assert(! ("d" in "abc"), "Not in string")

# ===============================
# TEST SUMMARY
# ===============================

print("\n--- TEST SUMMARY ---")
print("Total tests: ${total_tests}")
print("Passed tests: ${passed_tests}")
print("Failed tests: ${total_tests - passed_tests}")
print("Success rate: ${(passed_tests * 100) / total_tests}%")

if passed_tests == total_tests {
    print("\nüéâ ALL TESTS PASSED! Latch is working correctly.")
} else {
    print("\n‚ö†Ô∏è  Some tests failed. Review the implementation.")
}

print("\n=== LATCH EDGE CASES & UNIT TESTS COMPLETED ===")
stop 0
