# ===============================
# LATCH EDGE CASES & UNIT TESTS
# Boundary conditions and error scenarios
# ===============================

print("=== LATCH EDGE CASES & UNIT TESTS START ===")

# Helper function to report test results
fn assert(condition, message) {
    if condition {
        print("âœ“ PASS: ${message}")
    } else {
        print("âœ— FAIL: ${message}")
    }
}

# ===============================
# 1. NUMERIC EDGE CASES
# ===============================

print("\n--- NUMERIC EDGE CASES ---")

# Zero operations
assert(0 + 0 == 0, "Zero addition")
assert(0 * 5 == 0, "Zero multiplication")
assert(5 * 0 == 0, "Zero multiplication reverse")

# Large numbers
big_num := 999999999
assert(big_num > 0, "Large number handling")

# Float edge cases
assert(3.14159 > 3.14, "Float comparison")

# ===============================
# 2. STRING EDGE CASES
# ===============================

print("\n--- STRING EDGE CASES ---")

# Empty strings
empty := ""
assert(len(empty) == 0, "Empty string length")

# String with special characters
special := "Hello\nWorld\t!@#$%^&*()"
assert(len(special) > 10, "Special character string")

# Unicode strings
unicode := "Hello ä¸–ç•Œ ðŸŒ"
assert(len(unicode) > 5, "Unicode string handling")

# ===============================
# 3. BOOLEAN LOGIC EDGE CASES
# ===============================

print("\n--- BOOLEAN LOGIC EDGE CASES ---")

# Truthy/falsy values
assert(true && true == true, "True AND true")
assert(true && false == false, "True AND false")
assert(true || false == true, "True OR false")
assert(false || false == false, "False OR false")

# Negation
assert(!true == false, "Not true")
assert(!false == true, "Not false")

# ===============================
# 4. NULL HANDLING EDGE CASES
# ===============================

print("\n--- NULL HANDLING EDGE CASES ---")

# Null comparisons
assert(null == null, "Null equality")

# Null coalescing
assert(null ?? "default" == "default", "Null coalescing with null")
assert("value" ?? "default" == "value", "Null coalescing with value")

# Safe access with null
null_var := null
assert(null_var?.property == null, "Safe access on null")

# ===============================
# 5. FUNCTION EDGE CASES
# ===============================

print("\n--- FUNCTION EDGE CASES ---")

# No parameters
fn no_params() {
    return "no_params_result"
}
assert(no_params() == "no_params_result", "No parameter function")

# Multiple parameters
fn multi_params(a, b, c) {
    return a + b + c
}
assert(multi_params(1, 2, 3) == 6, "Multiple parameters")

# Recursive function edge case
fn recursive_sum(n) {
    if n <= 0 {
        return 0
    } else {
        return n + recursive_sum(n - 1)
    }
}
assert(recursive_sum(5) == 15, "Recursive function")

# ===============================
# 6. ERROR HANDLING EDGE CASES
# ===============================

print("\n--- ERROR HANDLING EDGE CASES ---")

# Type conversion errors
caught_type_error := false
try {
    x := int("not_a_number")
} catch e {
    caught_type_error = true
}
assert(caught_type_error, "Type conversion error caught")

# File not found error
caught_file_error := false
try {
    content := fs.read("definitely_not_existing_file.txt")
} catch e {
    caught_file_error = true
}
assert(caught_file_error, "File not found error caught")

# ===============================
# 7. OPERATOR PRECEDENCE EDGE CASES
# ===============================

print("\n--- OPERATOR PRECEDENCE EDGE CASES ---")

# Complex arithmetic
assert(2 + 3 * 4 == 14, "Multiplication precedence")
assert((2 + 3) * 4 == 20, "Parentheses override")

# Logical and arithmetic
assert(5 > 3 && 2 < 4 == true, "Comparison and logical precedence")

# Helper function for sum
fn sum_list(numbers) {
    total := 0
    for num in numbers {
        total += num
    }
    return total
}

# Pipe operator precedence
result := [1, 2, 3] |> map(fn(x) { return x * 2 }) |> sum_list()
assert(result == 12, "Pipe operator precedence")

# ===============================
# 8. TYPE COERCION EDGE CASES
# ===============================

print("\n--- TYPE COERCION EDGE CASES ---")

# String to number
assert(int("42") == 42, "String to int conversion")
assert(float("3.14") == 3.14, "String to float conversion")

# Number to string
assert(str(42) == "42", "Int to string conversion")
assert(str(3.14) == "3.14", "Float to string conversion")

# Boolean to string
assert(str(true) == "true", "Boolean true to string")
assert(str(false) == "false", "Boolean false to string")

# Invalid conversions
caught_invalid_int := false
try {
    x := int("")
} catch e {
    caught_invalid_int = true
}
assert(caught_invalid_int, "Invalid int conversion caught")

# ===============================
# 9. MEMORY EDGE CASES
# ===============================

print("\n--- MEMORY EDGE CASES ---")

# Large string creation
large_string := ""
for i in 0..1000 {
    large_string += "x"
}
print("Large string creation: ${len(large_string)} chars")

# Large list creation
large_list := range(0, 1000)
assert(len(large_list) == 1000, "Large list creation")

# Memory cleanup
large_string := null
large_list := null
assert(large_string == null, "Memory cleanup string")
assert(large_list == null, "Memory cleanup list")

# ===============================
# 10. SAFE ACCESS EDGE CASES
# ===============================

print("\n--- SAFE ACCESS EDGE CASES ---")

# Deep safe access chain
deep_data := {"a": {"b": {"c": {"d": "value"}}}}
assert(deep_data?.a?.b?.c?.d == "value", "Deep safe access")

# Safe access with missing property
missing_data := {"a": {"b": {}}}
assert(missing_data?.a?.b?.c?.d == null, "Safe access missing property")

# Safe access on null
null_data := null
assert(null_data?.anything == null, "Safe access on null")

# ===============================
# 11. IN OPERATOR EDGE CASES
# ===============================

print("\n--- IN OPERATOR EDGE CASES ---")

# In empty collections
assert(! (5 in []), "Not in empty list")
assert(! ("key" in {}), "Not in empty dict")

# In single item collections
assert(5 in [5], "In single item list")
assert("key" in {"key": "value"}, "In single item dict")

# String membership
assert("a" in "abc", "Character in string")
assert("ab" in "abc", "Substring in string")
assert(! ("d" in "abc"), "Not in string")

print("\n=== LATCH EDGE CASES & UNIT TESTS COMPLETED ===")
print("All edge cases tested successfully!")
stop 0
